class Analysis::Lhs
  include Analysis::Core # pivots and static vars

  def initialize(analysis_id, options = {})
    defaults = {
        skip_init: false,
        run_data_point_filename: "run_openstudio_workflow.rb"
    }
    @options = defaults.merge(options)
    @analysis_id = analysis_id
  end

  # Perform is the main method that is run in the background.  At the moment if this method crashes
  # it will be logged as a failed delayed_job and will fail after max_attempts.
  def perform
    require 'rserve/simpler'
    require 'uuid'
    require 'childprocess'

    # get the analysis and report that it is running
    @analysis = Analysis.find(@analysis_id)
    @analysis.status = 'started'
    @analysis.end_time = nil
    @analysis.run_flag = true

    # Set this if not defined in the JSON
    @analysis.problem['number_of_samples'] ||= 100
    @analysis.problem['random_seed'] ||= 1979
    @analysis.save!

    # Create an instance for R
    @r = Rserve::Simpler.new
    #lhs = Analysis::RWrapper::Lhs.new(@r)

    Rails.logger.info "Initializing analysis for #{@analysis.name} with UUID of #{@analysis.uuid}"
    Rails.logger.info "Setting up R for #{self.class.name}"
    #todo: need to move this to the module class
    @r.converse('setwd("/mnt/openstudio")')
    
    # make this a core method
    @r.converse("set.seed(#{@analysis.problem['random_seed']})")

    pivot_array = Variable.pivot_array(@analysis.id)
    static_array = Variable.static_array(@analysis.id)
    selected_variables = Variable.variables(@analysis.id)
    Rails.logger.info "Found #{selected_variables.count} variables to perturb"

    # generate the probabilities for all variables as column vectors
    @r.converse("print('starting lhs')")
    Rails.logger.info "Starting sampling"
    lhs = Analysis::R::Lhs.new(@r)
    samples, var_types = lhs.sample_variables(selected_variables, @analysis.problem['number_of_samples'])
    
    # Do the work to mash up the samples, pivots, and static variables before creating the data points
    Rails.logger.info "Samples are #{samples}"
    samples = hash_of_array_to_array_of_hash(samples)
    Rails.logger.info "Flipping samples around yields #{samples}"

    Rails.logger.info "Fixing Pivot dimension"
    samples = add_pivots(samples, pivot_array)
    Rails.logger.info "Finished adding the pivots resulting in #{samples}"

    Rails.logger.info "Adding in static variables"
    samples = add_static_variables(samples, static_array)
    Rails.logger.info "Samples after static_array #{samples}"

    # Add the data points to the database
    isample = 0
    samples.each do |sample| # do this in parallel
      isample += 1
      dp_name = "LHS Autogenerated #{isample}"
      dp = @analysis.data_points.new(name: dp_name)
      dp.set_variable_values = sample
      dp.save!

      Rails.logger.info("Generated data point #{dp.name} for analysis #{@analysis.name}")
    end

    # Do one last check if there are any data points that were not downloaded
    @analysis.end_time = Time.now
    @analysis.status = 'completed'
    @analysis.save!

    Rails.logger.info("Finished running #{self.class.name}")
  end

  # Since this is a delayed job, if it crashes it will typically try multiple times.
  # Fix this to 1 retry for now.
  def max_attempts
    return 1
  end
end

